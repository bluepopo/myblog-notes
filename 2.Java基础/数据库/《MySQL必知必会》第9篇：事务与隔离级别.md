

# 一、数据库设计原则

## 1 . 三大范式

1NF ： 每一列都是不可分割的原子数据项



2NF：在1NF的基础上，非码属性必须完全依赖于码（在1NF基础上**消除**非主属性对主码的**部分函数依赖**）

**第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）**



3NF ： 在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）

[关系型数据库设计：三大范式的通俗理解](https://www.cnblogs.com/wsg25/p/9615100.html)







# 二、事务

## 3.1 四大特性 ACID

原子性 ：是不可分割的最小操作单位，要么同时成功，要么同时失败。

持久性 ： 当事务提交或回滚后，数据库会持久化的保存数据。

隔离性 ： 多个事务之间。相互独立。

一致性 ：事务操作前后，数据总量不变





## 3.2 事务的隔离级别

==并发性问题==

* 概念：多个事务之间隔离的，相互独立的。但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题。

* 存在问题：
            1. **脏读：**一个事务，读取到另一个事务中没有提交的数据
            2. **不可重复读**：在同一个事务中，多次查询同一数据返回不同结果。
            3. 幻读 ：一个事务操作(DML)数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。

     > 不可重复读是指对于数据库中的某个数据，一个事务执行过程中多次查询返回不同查询结果，这就是在事务执行过程中，数据被其他事务提交修改了。
     > <font color=red>不可重复读同脏读的区别在于，脏读是一个事务读取了另一未完成的事务执行过程中的数据，而不可重复读是一个事务执行过程中，另一事务提交并修改了当前事务正在读取的数据。</font>

     

     

     > 幻读是事务非独立执行时发生的一种现象，例如事务T1批量对一个表中某一列列值为1的数据修改为2的变更，但是在这时，事务T2对这张表插入了一条列值为1的数据，并完成提交。此时，如果事务T1查看刚刚完成操作的数据，发现还有一条列值为1的数据没有进行修改，而这条数据其实是T2刚刚提交插入的，这就是幻读。
     >
     > <font color=red>幻读和不可重复读都是读取了另一条已经提交的事务（这点同脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）</font>







==隔离级别==

 1. <font color=blue>read uncommitted：读未提交</font>
              
                 * 产生的问题：脏读、不可重复读、幻读
              
              > 最低的隔离级别，但是并发性能最高，指的是一个事务可以读取到另外一个事务并未提交的数据。
              >
              > 如果一个事务已经开始写数据，则另外一个事务则不允许同时进行写操作，<font color=red>但允许其他事务读此行数据（写操作加写锁，读操作不加锁）</font>。
              
              

 2. <font color=blue>read committed：读已提交 （Oracle）</font>
              
                 * 产生的问题：不可重复读、幻读
              
              > Read Committed（读已提交）：指的是一个事务的更新操作在未提交之前，另外一个事务是读取不到同一数据更新后的结果，这就避免了脏读。读已提交会锁定当前正在读取的行的数据（ 写操作加写锁，读操作加读锁）。
              
              

   3. <font color=blue>repeatable read：可重复读 （MySQL默认）</font>
                
                
                 * 产生的问题：幻读
                
                > ​	Repeatable Read（可重复读）：mysql的默认的隔离级别，指的是在一个事务内，对相同条件的数据读取结果是相同的，不管其他事务有没有对其进行更新，也不管更新是否已经提交到数据库。<font color=red>可重复读会锁定读取到的所有行直到事务结束，其他事务的更新操作只能等到事务结束之后才能进行。</font>可重复读避免了脏读、不可重复读，但是会出现幻读问题。



  4. <font color=blue>serializable：串行化</font>
           
           
             * 可以解决所有的问题
           
           > Serializable（串行化）：最高的隔离级别，当然并发性能最低。<font color=red>指的是所有的事务操作依次顺序执行，事务只能一个接着一个执行，不能并发执行。</font>可序列化对表进行加锁，可以有效避免脏读、不可重复读、幻读问题，但是效率比较低，通常会用其他并发级别加上相应的并发锁机制来取代它。
           
           

## 3.3 修改隔离级别的方法

https://blog.csdn.net/sinat_35322593/article/details/81040479?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.nonecase





## 3.4 事务的使用

### 事务保留点 savepoint

```sql

SET autocommit=0; -- 手动开启事务
START TRANSACTION;

DELETE FROM account WHERE id=25;-- 删除操作

SAVEPOINT a;-- 设置保存点 a

DELETE FROM account WHERE id=28;

ROLLBACK TO a;-- 如果发生异常，回滚到保存点 a
```





